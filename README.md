# Sketchat
MultiPlayer Sketch Tool (C++ IOCP Server, Unity C# Client)

## 프로젝트 소개
Sketch + Chat = Sketchat <br/>
멀티플레이어로 그림을 그리는 응용프로그램. <br/>

[YoutubeLink](https://youtu.be/JGcvxF2Ymkk) <br/>

## 동기화 요소
실시간으로 원하는 위치의 픽셀을 변화시키는 정도는 단순하지만, <br/>
그렸던 그림을 되돌리는 Undo 기능을 넣으면 고려할 점이 많아진다. <br/>

일단 Undo 기능을 구현하려면 "획"의 개념이 필요하기 때문에, <br/>
DrawCommand로 데이터를 묶어 고려한다. <br/>
그리는 선의 굵기, 선의 색, 그리고 각각의 선분을 표현할 점들의 집합으로 구성된다. <br/>

그리고 DrawCommand가 완성되는 시점은 유저가 드래그를 해제하는 경우이다. <br/>
드래그를 해제하는 순간을 기준으로 동기화를 한다. <br/>
완성된 DrawCommand를 최근 기준으로 각각 클라이언트와 서버가 저장하고, <br/>
완성된 DrawCommand의 순서에 따라 Undo를 호출할 수 있도록 한다. <br/>
또한 모든 유저가 그리기를 마친 상태에서만 Undo를 호출할 수 있도록 했다. <br/>

새롭게 방에 입장하는 유저는 그동안 서버에 누적된 DrawCommand들을 전송받고 동기화한다. <br/>

만약 캔버스의 상태 그대로 전달받고 싶다면 데이터 압축과 스트리밍 방식의 처리가 필요할 듯 싶다. <br/>
(각각의 float을 1byte의 값으로 치환하는 방식으로 픽셀당 12바이트에서 3바이트로 줄일 수 있고, <br/>
더 나아가 색의 제한을 16개로 둔다면 픽셀당 4비트로 표현가능하다.)

## 패킷 발생량 제한
서버에 Draw동작을 요청하는 건 드래그 중인 상황에서 프레임마다 발생할 수 있다. <br/>
이를 0.03초 이내에 재전송하지 않도록 제한하고, 마우스의 위치가 x 또는 y축으로 변화한 경우에만 서버에 전달하도록 하여 <br/>
과도한 패킷이 발생하는 것을 방지하였다.

## JSON 직렬화 라이브러리 대신 직접 만든 직렬화 라이브러리 사용
[메모리 복사를 활용한 직렬화 라이브러리](https://github.com/SuhYC/DIY/tree/main/SerializeLib/CppToCS)를 적용하여 통신해봤다. <br/>
다만, 패딩을 없애고 객체단위로 메모리 복사하는 방식도 생각해볼 수 있겠는데, 둘 중 어느 방식이 더 효율적인지는 다음에 비교해봐야겠다. <br/>
지금 생각나는 점은 속도면에서는 객체단위 복사가 빠를 것이고, 변수단위 복사는 메모리 정렬을 맞춘 상태로 동작하기 때문에 복잡한 계산에서 이득을 볼 가능성이 있다는 것 정도? <br/>
(물론 후자가 개인프로젝트 면에서 이득볼 여지는 적다는 생각은 든다.)

## 비동기 송수신 로직 분리
[송수신 속도 개선 작업](https://github.com/SuhYC/100k_IO_EchoServer)에서 했던 것처럼 송신 흐름과 수신 흐름을 분리하였다. <br/>

## Build 후 통신 먹통 현상
에디터 상에서는 잘 되던 TCP송수신이 빌드 후 애플리케이션에서 여는 순간 안되는 현상이 발생한다. <br/>
이유는 ```Encoding.GetEncoding("euc-kr")``` 때문. <br/>
해당 기능이 있는 dll이 빌드하면서 같이 이동하지 않아서 생기는 오류라고 한다. <br/>
에디터버전 폴더에서 ```\Editor\Data\MonoBleedingEdge\lib\mono\4.5```폴더에 있는 ```I18N.CJK.dll```과 ```I18N.dll```을 복사하여 exe파일과 같은 디렉토리에 두면 해결된다.
